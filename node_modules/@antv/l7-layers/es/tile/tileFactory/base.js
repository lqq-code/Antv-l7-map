import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

import Source from '@antv/l7-source';
import { osmLonLat2TileXY } from '@antv/l7-utils';
import MaskLayer from '../../mask';
import { getLayerShape, readRasterValue, registerLayers } from '../utils';
import VectorLayer from './vectorLayer';
import * as turf from '@turf/helpers';
import union from '@turf/union';

var TileFactory = function () {
  function TileFactory(option) {
    _classCallCheck(this, TileFactory);

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "parentLayer", void 0);

    _defineProperty(this, "mapService", void 0);

    _defineProperty(this, "rendererService", void 0);

    _defineProperty(this, "outSideEventTimer", null);

    _defineProperty(this, "zoomOffset", void 0);

    _defineProperty(this, "tilesetManager", void 0);

    _defineProperty(this, "layers", void 0);

    _defineProperty(this, "eventCache", {
      click: 0,
      mousemove: 0,
      mouseup: 0,
      mousedown: 0,
      contextmenu: 0
    });

    this.parentLayer = option.parent;
    this.mapService = option.mapService;
    this.rendererService = option.rendererService;
    var source = this.parentLayer.getSource();
    this.zoomOffset = source.parser.zoomOffset || 0;
    this.tilesetManager = source.tileset;
  }

  _createClass(TileFactory, [{
    key: "createTile",
    value: function createTile(tile, initOptions) {
      return {
        layers: [],
        layerIDList: []
      };
    }
  }, {
    key: "getFeatureData",
    value: function getFeatureData(tile, initOptions) {
      var emptyData = {
        features: [],
        featureId: null,
        vectorTileLayer: null,
        source: null
      };
      var sourceLayer = initOptions.sourceLayer,
          featureId = initOptions.featureId;

      if (!sourceLayer) {
        return emptyData;
      }

      var vectorTileLayer = tile.data.layers[sourceLayer];
      var features = vectorTileLayer === null || vectorTileLayer === void 0 ? void 0 : vectorTileLayer.features;

      if (!(Array.isArray(features) && features.length > 0)) {
        return emptyData;
      } else {
        var source = new Source({
          type: 'FeatureCollection',
          features: features
        }, {
          parser: {
            type: 'geojson',
            featureId: featureId
          }
        });
        return {
          features: features,
          featureId: featureId,
          vectorTileLayer: vectorTileLayer,
          source: source
        };
      }
    }
  }, {
    key: "createLayer",
    value: function createLayer(tileLayerOption) {
      var L7Layer = tileLayerOption.L7Layer,
          tile = tileLayerOption.tile,
          initOptions = tileLayerOption.initOptions,
          vectorTileLayer = tileLayerOption.vectorTileLayer,
          source = tileLayerOption.source;
      var mask = initOptions.mask,
          color = initOptions.color,
          layerType = initOptions.layerType,
          size = initOptions.size,
          shape = initOptions.shape;
      var FactoryTileLayer = L7Layer ? L7Layer : VectorLayer;
      var layer = new FactoryTileLayer(_objectSpread({
        visible: tile.isVisible,
        tileOrigin: vectorTileLayer === null || vectorTileLayer === void 0 ? void 0 : vectorTileLayer.l7TileOrigin,
        coord: vectorTileLayer === null || vectorTileLayer === void 0 ? void 0 : vectorTileLayer.l7TileCoord
      }, this.getLayerInitOption(initOptions)));

      if (layer.isVector) {
        this.emitEvent([layer]);
        layer.type = layerType;
        layer.select(true);
      }

      layer.source(source);
      this.setScale(layer);
      this.setStyleAttributeField(layer, 'shape', shape);
      this.setStyleAttributeField(layer, 'color', color);
      this.setStyleAttributeField(layer, 'size', size);
      var layers = [layer];

      if (mask && layer.isVector) {
        var masklayer = new MaskLayer().source({
          type: 'FeatureCollection',
          features: [tile.bboxPolygon]
        }).shape('fill');
        layers.push(masklayer);
        layer.addMaskLayer(masklayer);
      }

      registerLayers(this.parentLayer, layers);
      this.layers = [layer];
      return layer;
    }
  }, {
    key: "updateStyle",
    value: function updateStyle(styles) {
      return '';
    }
  }, {
    key: "getDefautStyleAttributeField",
    value: function getDefautStyleAttributeField(layer, type) {
      switch (type) {
        case 'size':
          return 2;

        case 'color':
          return '#fff';

        case 'shape':
          return getLayerShape(this.parentLayer.type, layer);

        default:
          return '';
      }
    }
  }, {
    key: "setStyleAttributeField",
    value: function setStyleAttributeField(layer, type, value) {
      if (Array.isArray(value)) {
        layer[type].apply(layer, _toConsumableArray(value));
        return;
      }

      if (typeof value === 'string') {
        layer[type](value);
        return;
      }

      var defaultValue = this.getDefautStyleAttributeField(layer, type);

      if (!value) {
        layer[type](defaultValue);
        return layer;
      }

      var params = this.parseScaleValue(value, type);

      if (params.length === 0) {
        layer[type](defaultValue);
      } else {
        layer[type].apply(layer, _toConsumableArray(params));
      }
    }
  }, {
    key: "parseScaleValue",
    value: function parseScaleValue(value, type) {
      if (type === 'shape') {
        if (typeof value === 'string') {
          return [value];
        } else if (value !== null && value !== void 0 && value.field) {
          return [value === null || value === void 0 ? void 0 : value.field];
        } else {
          return [];
        }
      }

      var _ref = value,
          field = _ref.field,
          values = _ref.values,
          callback = _ref.callback;

      if (field && values && Array.isArray(values)) {
        return [field, values];
      } else if (field && callback) {
        return [field, callback];
      } else if (field) {
        return [field];
      }

      return [];
    }
  }, {
    key: "getTile",
    value: function getTile(lng, lat) {
      var zoom = this.mapService.getZoom();
      var z = Math.ceil(zoom) + this.zoomOffset;
      var xy = osmLonLat2TileXY(lng, lat, z);
      var tiles = this.tilesetManager.tiles.filter(function (t) {
        return t.key === "".concat(xy[0], ",").concat(xy[1], ",").concat(z);
      });
      var tile = tiles[0];
      return tile;
    }
  }, {
    key: "emitEvent",
    value: function emitEvent(layers, isVector) {
      var _this = this;

      layers.map(function (layer) {
        layer.once('inited', function () {
          layer.on('click', function (e) {
            _this.eventCache.click = 1;

            if (_this.parentLayer.type === 'RasterLayer') {
              var _e$lngLat = e.lngLat,
                  lng = _e$lngLat.lng,
                  lat = _e$lngLat.lat;

              var tile = _this.getTile(lng, lat);

              _this.getFeatureAndEmitEvent(layer, 'subLayerClick', e, isVector, tile);
            } else {
              _this.getFeatureAndEmitEvent(layer, 'subLayerClick', e);
            }
          });
          layer.on('mousemove', function (e) {
            _this.eventCache.mousemove = 1;

            if (_this.parentLayer.type === 'RasterLayer') {
              var _e$lngLat2 = e.lngLat,
                  lng = _e$lngLat2.lng,
                  lat = _e$lngLat2.lat;

              var tile = _this.getTile(lng, lat);

              _this.getFeatureAndEmitEvent(layer, 'subLayerMouseMove', e, isVector, tile);
            } else {
              _this.getFeatureAndEmitEvent(layer, 'subLayerMouseMove', e);
            }
          });
          layer.on('mouseup', function (e) {
            _this.eventCache.mouseup = 1;

            _this.getFeatureAndEmitEvent(layer, 'subLayerMouseUp', e);
          });
          layer.on('mouseenter', function (e) {
            if (_this.parentLayer.type === 'RasterLayer') {
              var _e$lngLat3 = e.lngLat,
                  lng = _e$lngLat3.lng,
                  lat = _e$lngLat3.lat;

              var tile = _this.getTile(lng, lat);

              _this.getFeatureAndEmitEvent(layer, 'subLayerMouseMove', e, isVector, tile);
            } else {
              _this.getFeatureAndEmitEvent(layer, 'subLayerMouseEnter', e);
            }
          });
          layer.on('mouseout', function (e) {
            _this.getFeatureAndEmitEvent(layer, 'subLayerMouseOut', e);
          });
          layer.on('mousedown', function (e) {
            _this.eventCache.mousedown = 1;

            _this.getFeatureAndEmitEvent(layer, 'subLayerMouseDown', e);
          });
          layer.on('contextmenu', function (e) {
            _this.eventCache.contextmenu = 1;

            _this.getFeatureAndEmitEvent(layer, 'subLayerContextmenu', e);
          });
          layer.on('unclick', function (e) {
            return _this.handleOutsideEvent('click', 'subLayerUnClick', layer, e);
          });
          layer.on('unmouseup', function (e) {
            return _this.handleOutsideEvent('mouseup', 'subLayerUnMouseUp', layer, e);
          });
          layer.on('unmousedown', function (e) {
            return _this.handleOutsideEvent('mousedown', 'subLayerUnMouseDown', layer, e);
          });
          layer.on('uncontextmenu', function (e) {
            return _this.handleOutsideEvent('contextmenu', 'subLayerUnContextmenu', layer, e);
          });
        });
      });
    }
  }, {
    key: "getCombineFeature",
    value: function getCombineFeature(features) {
      var p = null;
      var properties = features[0];
      features.map(function (feature) {
        var polygon = turf.polygon(feature.coordinates);

        if (p === null) {
          p = polygon;
        }

        {
          p = union(p, polygon);
        }
      });

      if (properties) {
        p.properties = _objectSpread({}, properties);
      }

      return p;
    }
  }, {
    key: "getFeatureAndEmitEvent",
    value: function getFeatureAndEmitEvent(layer, eventName, e, isVector, tile) {
      if (isVector === false) {
        e.value = readRasterValue(tile, this.mapService, e.x, e.y);
      } else {
        var featureId = e.featureId;
        var features = this.getAllFeatures(featureId);

        try {
          e.feature = this.getCombineFeature(features);
        } catch (err) {
          console.warn('Combine Featuer Err! Return First Feature!');
          e.feature = features[0];
        }
      }

      this.parentLayer.emit(eventName, e);
    }
  }, {
    key: "setScale",
    value: function setScale(layer) {
      var scaleOptions = this.parentLayer.tileLayer.scaleField;
      var scaleKeys = Object.keys(scaleOptions);
      scaleKeys.map(function (key) {
        layer.scale(key, scaleOptions[key]);
      });
    }
  }, {
    key: "getAllFeatures",
    value: function getAllFeatures(featureId) {
      var allLayers = this.parentLayer.tileLayer.children;
      var features = [];
      allLayers.map(function (layer) {
        var source = layer.getSource();
        source.data.dataArray.map(function (feature) {
          if (feature._id === featureId) {
            features.push(feature);
          }
        });
      });
      return features;
    }
  }, {
    key: "getLayerInitOption",
    value: function getLayerInitOption(initOptions) {
      var option = _objectSpread({}, initOptions);

      delete option.color;
      delete option.shape;
      delete option.size;
      delete option.coords;
      delete option.sourceLayer;
      delete option.coords;
      return option;
    }
  }, {
    key: "handleOutsideEvent",
    value: function handleOutsideEvent(type, emitType, layer, e) {
      var _this2 = this;

      if (this.outSideEventTimer) {
        clearTimeout(this.outSideEventTimer);
        this.outSideEventTimer = null;
      }

      this.outSideEventTimer = setTimeout(function () {
        if (_this2.eventCache[type] > 0) {
          _this2.eventCache[type] = 0;
        } else {
          _this2.getFeatureAndEmitEvent(layer, emitType, e);
        }
      }, 64);
    }
  }]);

  return TileFactory;
}();

export { TileFactory as default };
//# sourceMappingURL=base.js.map