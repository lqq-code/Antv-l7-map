{"version":3,"sources":["../../../src/tileset-manager/utils/strategies.ts"],"names":["TILE_STATE_DEFAULT","TILE_STATE_VISITED","TILE_STATE_VISIBLE","updateTileStateRealtime","tiles","forEach","tile","isCurrent","isVisible","isLoaded","updateTileStateOverlap","properties","state","getPlaceholderInAncestors","getPlaceholderInChildren","Boolean","updateTileStateReplace","sortedTiles","slice","sort","t1","t2","z","children","length","child","parent"],"mappings":"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","sourcesContent":["import { Tile } from '../tile';\n\n// 访问状态\nconst TILE_STATE_DEFAULT = 0;\n// 访问状态\nconst TILE_STATE_VISITED = 1;\n// 可见状态\nconst TILE_STATE_VISIBLE = 2;\n\n/*\n * 瓦片更新状态策略 - 实时更新策略\n * 当前视野 currentTile 请求到数据就立即显示\n * 请求中的数据不显示不填补，渲染留白\n */\nexport function updateTileStateRealtime(tiles: Tile[]) {\n  tiles.forEach((tile) => {\n    if (tile.isCurrent) {\n      tile.isVisible = tile.isLoaded;\n    }\n  });\n}\n\n/*\n * 瓦片更新状态策略 - 渐近更新策略\n * 对于当前视野 currentTile 且数据请求中的瓦片\n * 用最近上级的瓦片作为占位符\n * 如果没有最近上级瓦片可用，用最近的子级瓦片作为占位符\n */\nexport function updateTileStateOverlap(tiles: Tile[]) {\n  tiles.forEach((tile) => {\n    tile.properties.state = TILE_STATE_DEFAULT;\n  });\n  tiles.forEach((tile) => {\n    if (tile.isCurrent && !getPlaceholderInAncestors(tile)) {\n      getPlaceholderInChildren(tile);\n    }\n  });\n  tiles.forEach((tile) => {\n    tile.isVisible = Boolean(tile.properties.state & TILE_STATE_VISIBLE);\n  });\n}\n\n/*\n * 瓦片更新状态策略 - 全部替换策略\n * 对于当前视野的所有 currentTile 瓦片在加载完成之前，使用最近的上级瓦片作为占位符\n */\nexport function updateTileStateReplace(tiles: Tile[]) {\n  tiles.forEach((tile) => {\n    tile.properties.state = TILE_STATE_DEFAULT;\n  });\n  // 更新当前视野瓦片的上级瓦片可见状态\n  tiles.forEach((tile) => {\n    if (tile.isCurrent) {\n      getPlaceholderInAncestors(tile);\n    }\n  });\n\n  // 通过 zoom 层级排序，最小的层级在上面\n  const sortedTiles = tiles.slice().sort((t1, t2) => t1.z - t2.z);\n\n  sortedTiles.forEach((tile) => {\n    tile.isVisible = Boolean(tile.properties.state & TILE_STATE_VISIBLE);\n\n    if (\n      tile.children.length &&\n      (tile.isVisible || tile.properties.state & TILE_STATE_VISITED)\n    ) {\n      // 如果瓦片可见，隐藏所有的子级瓦片\n      tile.children.forEach((child) => {\n        child.properties.state = TILE_STATE_VISITED;\n      });\n    } else if (tile.isCurrent) {\n      getPlaceholderInChildren(tile);\n    }\n  });\n}\n\n/*\n * 查找上级已加载的瓦片作为占位符\n * 如果找到返回 true\n */\nfunction getPlaceholderInAncestors(tile: Tile | null) {\n  while (tile) {\n    if (tile.isLoaded) {\n      // tile.properties.state = tile.properties.state | TILE_STATE_VISIBLE\n      tile.properties.state |= TILE_STATE_VISIBLE;\n      return true;\n    }\n    tile = tile.parent;\n  }\n  return false;\n}\n\n/*\n * 递归查找将子级已加载瓦片作为占位符\n */\nfunction getPlaceholderInChildren(tile: Tile) {\n  tile.children.forEach((child) => {\n    if (child.isLoaded) {\n      child.properties.state |= TILE_STATE_VISIBLE;\n    } else {\n      getPlaceholderInChildren(child);\n    }\n  });\n}\n"],"file":"strategies.js"}