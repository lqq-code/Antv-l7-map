import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

import _regeneratorRuntime from "@babel/runtime/regenerator";
import { getArrayBuffer, getURLFromTemplate } from '@antv/l7-utils';
import { VectorTile } from '@mapbox/vector-tile';
import Protobuf from 'pbf';
var DEFAULT_CONFIG = {
  tileSize: 256,
  minZoom: 0,
  maxZoom: Infinity,
  zoomOffset: 0
};
var TILE_SIZE = 512;
export function osmTileXY2LonLat(x, y, zoom) {
  var lon = x / Math.pow(2, zoom) * 360 - 180;
  var n = Math.PI - 2 * Math.PI * y / Math.pow(2, zoom);
  var lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
  return [lon, lat];
}

function signedArea(ring) {
  var sum = 0;

  for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
    p1 = ring[i];
    p2 = ring[j];
    sum += (p2.x - p1.x) * (p1.y + p2.y);
  }

  return sum;
}

function classifyRings(rings) {
  var len = rings.length;

  if (len <= 1) {
    return [rings];
  }

  var polygons = [];
  var polygon;
  var ccw;

  for (var i = 0; i < len; i++) {
    var area = signedArea(rings[i]);

    if (area === 0) {
      continue;
    }

    if (ccw === undefined) {
      ccw = area < 0;
    }

    if (ccw === area < 0) {
      if (polygon) {
        polygons.push(polygon);
      }

      polygon = [rings[i]];
    } else {
      polygon.push(rings[i]);
    }
  }

  if (polygon) {
    polygons.push(polygon);
  }

  return polygons;
}

var VectorTileFeatureTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];

function GetGeoJSON(z, vectorTileFeature) {
  var extent = vectorTileFeature.extent;
  var coords = vectorTileFeature.loadGeometry();
  var currenType = vectorTileFeature.type;
  var currentProperties = vectorTileFeature.properties;
  var currentId = vectorTileFeature.id;
  var size = extent * Math.pow(2, z);
  var type = VectorTileFeatureTypes[currenType];
  var i;
  var j;

  function project(line) {
    for (var index = 0; index < line.length; index++) {
      var point = line[index];
      line[index] = [point.x / size * TILE_SIZE, point.y / size * TILE_SIZE];
    }
  }

  switch (currenType) {
    case 1:
      var points = [];

      for (i = 0; i < coords.length; i++) {
        points[i] = coords[i][0];
      }

      coords = points;
      project(coords);
      break;

    case 2:
      for (i = 0; i < coords.length; i++) {
        project(coords[i]);
      }

      break;

    case 3:
      coords = classifyRings(coords);

      for (i = 0; i < coords.length; i++) {
        for (j = 0; j < coords[i].length; j++) {
          project(coords[i][j]);
        }
      }

      break;
  }

  if (coords.length === 1) {
    coords = coords[0];
  } else {
    type = 'Multi' + type;
  }

  var result = {
    type: 'Feature',
    geometry: {
      type: type,
      coordinates: coords
    },
    properties: currentProperties,
    id: currentId,
    tileOrigin: [0, 0],
    coord: ''
  };
  return result;
}

var getVectorTile = function () {
  var _ref = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(url, tileParams, tile, coord) {
    var tileUrl;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            tileUrl = getURLFromTemplate(url, tileParams);
            return _context.abrupt("return", new Promise(function (resolve) {
              var xhr = getArrayBuffer({
                url: tileUrl
              }, function (err, data) {
                if (err || !data) {
                  resolve({
                    layers: {}
                  });
                } else {
                  var vectorTile = new VectorTile(new Protobuf(data));
                  var tileOrigin = osmTileXY2LonLat(tileParams.x, tileParams.y, tileParams.z);
                  var zoom = tileParams.z;

                  for (var _i = 0, _Object$keys = Object.keys(vectorTile.layers); _i < _Object$keys.length; _i++) {
                    var sourceLayer = _Object$keys[_i];
                    var features = [];
                    var vectorTileLayer = vectorTile.layers[sourceLayer];

                    for (var i = 0; i < vectorTile.layers[sourceLayer].length; i++) {
                      var vectorTileFeature = vectorTile.layers[sourceLayer].feature(i);
                      var feature = void 0;

                      if (coord === 'lnglat') {
                        feature = vectorTileFeature.toGeoJSON(tileParams.x, tileParams.y, tileParams.z);
                      } else {
                        feature = GetGeoJSON(zoom, vectorTileFeature);
                        vectorTileLayer.l7TileOrigin = tileOrigin;
                        vectorTileLayer.l7TileCoord = coord;
                      }

                      features.push(feature);
                    }

                    vectorTileLayer.features = features;
                  }

                  resolve(vectorTile);
                }
              });

              tile.xhrCancel = function () {
                return xhr.abort();
              };
            }));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getVectorTile(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();

export default function mapboxVectorTile(data, cfg) {
  var coord = (cfg === null || cfg === void 0 ? void 0 : cfg.coord) || 'lnglat';

  var getTileData = function getTileData(tileParams, tile) {
    return getVectorTile(data, tileParams, tile, coord);
  };

  var tilesetOptions = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_CONFIG), cfg), {}, {
    getTileData: getTileData
  });

  return {
    data: data,
    dataArray: [],
    tilesetOptions: tilesetOptions,
    isTile: true
  };
}
//# sourceMappingURL=mvt.js.map