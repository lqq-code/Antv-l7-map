{"version":3,"sources":["../../src/parser/geojson.ts"],"names":["rewind","getCoords","turfMeta","djb2hash","field","str","toString","hash","i","length","charCodeAt","getFeatureID","feature","key","undefined","id","properties","geoJSON","data","cfg","resultData","featureKeys","features","dataArray","filter","item","geometry","type","coordinates","flattenEach","currentFeature","featureIndex","featureId","sortedID","coord","dataItem","_id","push"],"mappings":"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","sourcesContent":["// @ts-ignore\nimport rewind from '@mapbox/geojson-rewind';\nimport {\n  Feature,\n  FeatureCollection,\n  Geometries,\n  Geometry,\n  Properties,\n} from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\nimport * as turfMeta from '@turf/meta';\nimport { IFeatureKey, IParseDataItem, IParserData } from '../interface';\ninterface IParserCFG {\n  idField?: string;\n  featureId?: string;\n  [key: string]: any;\n}\n\nfunction djb2hash(field: string) {\n  const str = field.toString();\n  let hash = 5381;\n  let i = str.length;\n\n  while (i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n\n  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */\n  return hash >>> 0;\n}\n\nfunction getFeatureID(feature: Feature<Geometries, Properties>, key?: string) {\n  if (key === undefined) {\n    return null;\n  }\n  if (key === 'id' && feature.id) {\n    // 标准 mapbox vector feature\n    return feature.id;\n  }\n  // @ts-ignore\n  if (feature[key]) {\n    // 单独指定要素\n    // @ts-ignore\n    return feature[key];\n  }\n  if (feature.properties && feature.properties[key]) {\n    // 根据 properties 要素的属性进行编码\n    return djb2hash(feature.properties[key] + '') % 1000019;\n  }\n  return null;\n}\n\nexport default function geoJSON(\n  data: FeatureCollection<Geometries, Properties>,\n  cfg?: IParserCFG,\n): IParserData {\n  const resultData: IParseDataItem[] = [];\n  const featureKeys: IFeatureKey = {};\n  if (!data.features) {\n    data.features = [];\n    return {\n      dataArray: [],\n    };\n  }\n  data.features = data.features.filter((item: Feature) => {\n    const geometry: Geometry | null = item.geometry as Geometry;\n    return (\n      item != null &&\n      geometry &&\n      geometry.type &&\n      geometry.coordinates &&\n      geometry.coordinates.length > 0\n    );\n  });\n  rewind(data, true); // 设置地理多边形方向 If clockwise is true, the outer ring is clockwise, otherwise it is counterclockwise.\n  if (data.features.length === 0) {\n    return {\n      dataArray: [],\n      featureKeys,\n    };\n  }\n  // multi polygon 拆分\n  turfMeta.flattenEach(\n    data,\n    (currentFeature: Feature<Geometries, Properties>, featureIndex: number) => {\n      let featureId = getFeatureID(currentFeature, cfg?.featureId);\n      if (featureId === null) {\n        featureId = featureIndex;\n      }\n      const sortedID = featureId;\n\n      const coord = getCoords(currentFeature);\n      const dataItem: IParseDataItem = {\n        ...currentFeature.properties,\n        coordinates: coord,\n        _id: sortedID,\n      };\n      resultData.push(dataItem);\n    },\n  );\n  return {\n    dataArray: resultData,\n    featureKeys,\n  };\n}\n"],"file":"geojson.js"}