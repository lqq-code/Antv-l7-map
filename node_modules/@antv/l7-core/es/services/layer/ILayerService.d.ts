import { SyncBailHook, SyncHook, SyncWaterfallHook } from '@antv/async-hook';
import { IColorRamp, IImagedata, Tile, TilesetManager } from '@antv/l7-utils';
import { Container } from 'inversify';
import Clock from '../../utils/clock';
import { ISceneConfig } from '../config/IConfigService';
import { IInteractionTarget } from '../interaction/IInteractionService';
import { IPickingService } from '../interaction/IPickingService';
import { IMapService } from '../map/IMapService';
import { IAttribute } from '../renderer/IAttribute';
import { IBlendOptions, IModel, IModelInitializationOptions } from '../renderer/IModel';
import { IMultiPassRenderer, IPass, IPostProcessingPass } from '../renderer/IMultiPassRenderer';
import { IRendererService } from '../renderer/IRendererService';
import { IUniform } from '../renderer/IUniform';
import { ISource, ISourceCFG } from '../source/ISourceService';
import { IAnimateOption, IEncodeFeature, IScale, IScaleOptions, IScaleValue, IStyleAttribute, IStyleAttributeService, IStyleAttributeUpdateOptions, StyleAttrField, StyleAttributeField, StyleAttributeOption, Triangulation } from './IStyleAttributeService';
export declare enum BlendType {
    normal = "normal",
    additive = "additive",
    subtractive = "subtractive",
    min = "min",
    max = "max",
    none = "none"
}
export interface IBlendTypes {
    [key: string]: Partial<IBlendOptions>;
}
export interface IDataState {
    dataSourceNeedUpdate: boolean;
    dataMappingNeedUpdate: boolean;
    filterNeedUpdate: boolean;
    featureScaleNeedUpdate: boolean;
    StyleAttrNeedUpdate: boolean;
}
export interface ILayerModelInitializationOptions {
    moduleName: string;
    vertexShader: string;
    fragmentShader: string;
    triangulation: Triangulation;
    segmentNumber?: number;
}
export interface ILayerModel {
    render(): void;
    renderUpdate?(): void;
    getUninforms(): IModelUniform;
    getDefaultStyle(): unknown;
    getAnimateUniforms(): IModelUniform;
    buildModels(): IModel[];
    initModels(): IModel[];
    needUpdate(): boolean;
    clearModels(): void;
    clearCanvas?(): void;
    setEarthTime?(time: number): void;
    createModelData?(options?: any): any;
}
export interface IModelUniform {
    [key: string]: IUniform;
}
export interface IPickedFeature {
    x: number;
    y: number;
    lnglat?: {
        lng: number;
        lat: number;
    };
    feature?: unknown;
}
export interface IActiveOption {
    color: string | number[];
    mix?: number;
}
declare type ILngLat = [number, number];
export interface ILegendSegmentItem {
    value: [number, number];
    [key: string]: any;
}
export interface ILegendClassificaItem {
    value: number | string;
    [key: string]: any;
}
export declare type LegendItems = ILegendSegmentItem[] | ILegendClassificaItem[];
export interface IAttrubuteAndElements {
    attributes: any;
    elements: any;
}
export interface ISubLayerStyles {
    opacity: number;
}
/**
 * For tile subLayer
 */
export interface ISubLayerInitOptions {
    layerType: string;
    shape?: string | string[] | IScaleValue;
    zIndex: number;
    mask: boolean;
    stroke?: string;
    strokeWidth?: number;
    strokeOpacity?: number;
    opacity: number;
    color?: IScaleValue;
    size?: IScaleValue;
    domain?: [number, number];
    clampLow?: boolean;
    clampHigh?: boolean;
    rampColors?: IColorRamp;
    rampColorsData?: ImageData | IImagedata;
    coords?: string;
    sourceLayer?: string;
    featureId?: string;
}
export interface ITilePickManager {
    isLastPicked: boolean;
    on(type: string, cb: (option: any) => void): void;
    normalRender(layers: ILayer[]): void;
    beforeHighlight(pickedColors: any): void;
    beforeSelect(pickedColors: any): void;
    clearPick(): void;
    pickRender(layers: ILayer[], target: IInteractionTarget): boolean;
}
export interface ITileLayerManager {
    sourceLayer: string;
    parent: ILayer;
    children: ILayer[];
    tilePickManager: ITilePickManager;
    createTile(tile: Tile): {
        layers: ILayer[];
        layerIDList: string[];
    };
    addChild(layer: ILayer): void;
    addChilds(layers: ILayer[]): void;
    getChilds(layerIDList: string[]): ILayer[];
    removeChild(layer: ILayer): void;
    removeChilds(layerIDList: string[], refresh?: boolean): void;
    clearChild(): void;
    hasChild(layer: ILayer): boolean;
    render(isPicking?: boolean): void;
    pickLayers(target: IInteractionTarget): boolean;
    updateLayersConfig(layers: ILayer[], key: string, value: any): void;
}
export interface ITileLayer {
    type: string;
    sourceLayer: string;
    parent: ILayer;
    tileLayerManager: ITileLayerManager;
    tilesetManager: TilesetManager | undefined;
    children: ILayer[];
    scaleField: any;
    render(isPicking?: boolean): void;
    pickLayers(target: IInteractionTarget): boolean;
    clearPick(type: string): void;
    clearPickState(): void;
}
export interface ITileLayerOPtions {
    parent: ILayer;
    rendererService: IRendererService;
    mapService: IMapService;
    layerService: ILayerService;
    pickingService: IPickingService;
}
export declare type LayerEventType = 'inited' | 'add' | 'remove' | 'destroy' | 'contextmenu' | 'uncontextmenu' | 'unpick' | 'mousedown' | 'unmousedown' | 'unclick' | 'undblclick' | 'unmouseenter' | 'unmousemove' | 'mouseout' | 'click' | 'dblclick' | 'mouseenter' | 'unmousemove' | 'mouseout' | any;
export interface ILayer {
    id: string;
    type: string;
    name: string;
    inited: boolean;
    zIndex: number;
    clusterZoom: number;
    plugins: ILayerPlugin[];
    layerModelNeedUpdate: boolean;
    styleNeedUpdate: boolean;
    layerModel: ILayerModel;
    tileLayer: ITileLayer;
    layerChildren: ILayer[];
    masks: ILayer[];
    sceneContainer: Container | undefined;
    dataState: IDataState;
    pickedFeatureID: number | null;
    hooks: {
        init: SyncBailHook;
        afterInit: SyncBailHook;
        beforeRenderData: SyncWaterfallHook;
        beforeRender: SyncBailHook;
        afterRender: SyncHook;
        beforePickingEncode: SyncHook;
        afterPickingEncode: SyncHook;
        beforeHighlight: SyncHook;
        beforeSelect: SyncHook;
        afterSelect: SyncHook;
        afterHighlight: SyncHook;
        beforeDestroy: SyncHook;
        afterDestroy: SyncHook;
    };
    models: IModel[];
    sourceOption: {
        data: any;
        options?: ISourceCFG;
    };
    multiPassRenderer: IMultiPassRenderer;
    layerType?: string | undefined;
    isVector?: boolean;
    triangulation?: Triangulation | undefined;
    /**
     * threejs 适配兼容相关的方法
     * @param lnglat
     * @param altitude
     * @param rotation
     * @param scale
     */
    threeRenderService?: any;
    getShaderPickStat: () => boolean;
    updateModelData(data: IAttrubuteAndElements): void;
    addMaskLayer(maskLayer: ILayer): void;
    removeMaskLayer(maskLayer: ILayer): void;
    needPick(type: string): boolean;
    getAttribute(name: string): IStyleAttribute | undefined;
    getLayerConfig(): Partial<ILayerConfig & ISceneConfig>;
    setBottomColor(color: string): void;
    getBottomColor(): string;
    getContainer(): Container;
    setContainer(container: Container, sceneContainer: Container): void;
    setCurrentPickId(id: number | null): void;
    getCurrentPickId(): number | null;
    setCurrentSelectedId(id: number | null): void;
    getCurrentSelectedId(): number | null;
    prepareBuildModel(): void;
    renderModels(isPicking?: boolean): void;
    buildModels(): void;
    rebuildModels(): void;
    buildLayerModel(options: ILayerModelInitializationOptions & Partial<IModelInitializationOptions>): IModel;
    createAttrubutes(options: ILayerModelInitializationOptions & Partial<IModelInitializationOptions>): {
        [attributeName: string]: IAttribute;
    };
    updateStyleAttribute(type: string, field: StyleAttributeField, values?: StyleAttributeOption, updateOptions?: Partial<IStyleAttributeUpdateOptions>): void;
    init(): ILayer;
    scale(field: string | number | IScaleOptions, cfg?: IScale): ILayer;
    getScale(name: string): any;
    size(field: StyleAttrField, value?: StyleAttributeOption): ILayer;
    color(field: StyleAttrField, value?: StyleAttributeOption): ILayer;
    rotate(field: StyleAttrField, value?: StyleAttributeOption): ILayer;
    texture(field: StyleAttrField, value?: StyleAttributeOption): ILayer;
    shape(field: StyleAttrField, value?: StyleAttributeOption): ILayer;
    label(field: StyleAttrField, value?: StyleAttributeOption): ILayer;
    animate(option: Partial<IAnimateOption> | boolean): ILayer;
    filter(field: string, value: StyleAttributeOption): ILayer;
    active(option: IActiveOption | boolean): ILayer;
    setActive(id: number | {
        x: number;
        y: number;
    }, option?: IActiveOption): void;
    select(option: IActiveOption | boolean): ILayer;
    setSelect(id: number | {
        x: number;
        y: number;
    }, option?: IActiveOption): void;
    setAutoFit(autoFit: boolean): void;
    style(options: unknown): ILayer;
    hide(): ILayer;
    show(): ILayer;
    getLegendItems(name: string): LegendItems;
    setIndex(index: number): ILayer;
    isVisible(): boolean;
    setMaxZoom(min: number): ILayer;
    setMinZoom(max: number): ILayer;
    getMinZoom(): number;
    getMaxZoom(): number;
    get(name: string): number;
    setBlend(type: keyof typeof BlendType): ILayer;
    setMultiPass(multipass: boolean, passes?: Array<string | [string, {
        [key: string]: unknown;
    }]>): ILayer;
    renderLayers(): void;
    render(): ILayer;
    renderMultiPass(): any;
    clear(): void;
    clearModels(): void;
    destroy(refresh?: boolean): void;
    source(data: any, option?: ISourceCFG): ILayer;
    setData(data: any, option?: ISourceCFG): ILayer;
    fitBounds(fitBoundsOptions?: unknown): ILayer;
    /**
     * 向当前图层注册插件
     * @param plugin 插件实例
     */
    addPlugin(plugin: ILayerPlugin): ILayer;
    getSource(): ISource;
    setSource(source: ISource): void;
    setEncodedData(encodedData: IEncodeFeature[]): void;
    getEncodedData(): IEncodeFeature[];
    getScaleOptions(): IScaleOptions;
    /**
     * 事件
     */
    on(type: LayerEventType, handler: (...args: any[]) => void): void;
    off(type: LayerEventType, handler: (...args: any[]) => void): void;
    emit(type: LayerEventType, handler: unknown): void;
    once(type: LayerEventType, handler: (...args: any[]) => void): void;
    isDirty(): boolean;
    /**
     * 直接调用拾取方法，在非鼠标交互场景中使用
     */
    pick(query: {
        x: number;
        y: number;
    }): void;
    boxSelect(box: [number, number, number, number], cb: (...args: any[]) => void): void;
    updateLayerConfig(configToUpdate: Partial<ILayerConfig | unknown>): void;
    setAnimateStartTime(): void;
    getLayerAnimateTime(): number;
    getModelMatrix?(lnglat: ILngLat, altitude: number, rotation: [number, number, number], scale: [number, number, number]): any;
    getTranslateMatrix?(lnglat: ILngLat, altitude?: number): any;
    applyObjectLngLat?(object: any, lnglat: ILngLat, altitude?: number): void;
    setObjectLngLat?(object: any, lnglat: ILngLat, altitude?: number): void;
    getObjectLngLat?(object: any): ILngLat;
    lnglatToCoord?(lnglat: ILngLat): ILngLat;
    adjustMeshToMap?(object: any): void;
    setMeshScale?(object: any, x: number, y: number, z: number): void;
    addAnimateMixer?(mixer: any): void;
    getRenderCamera?(): any;
    /**
     * 地球模式相关的方法
     */
    setEarthTime(time: number): void;
}
/**
 * Layer 插件
 */
export interface ILayerPlugin {
    apply(layer: ILayer, services: {
        rendererService: IRendererService;
        mapService: IMapService;
        styleAttributeService: IStyleAttributeService;
        postProcessingPassFactory: (name: string) => IPostProcessingPass<unknown>;
        normalPassFactory: (name: string) => IPass<unknown>;
    }): void;
}
/**
 * Layer 初始化参数
 */
export interface ILayerConfig {
    mask: boolean;
    maskInside: boolean;
    maskfence: any;
    maskColor: string;
    maskOpacity: number;
    colors: string[];
    size: number;
    shape: string;
    shape2d: string[];
    shape3d: string[];
    scales: {
        [key: string]: IScale;
    };
    minZoom: number;
    maxZoom: number;
    visible: boolean;
    zIndex: number;
    pickingBuffer: number;
    enablePropagation: boolean;
    autoFit: boolean;
    fitBoundsOptions?: unknown;
    name: string;
    blend: keyof typeof BlendType;
    depth: boolean;
    pickedFeatureID: number;
    enableMultiPassRenderer: boolean;
    passes: Array<string | [string, {
        [key: string]: unknown;
    }]>;
    layerType?: string | undefined;
    cursorEnabled?: boolean;
    cursor?: string;
    forward: boolean;
    /**
     * 开启拾取
     */
    enablePicking: boolean;
    /**
     * 开启高亮
     */
    enableHighlight: boolean;
    enableSelect: boolean;
    /**
     * 高亮颜色
     */
    highlightColor: string | number[];
    selectColor: string | number[];
    active: boolean;
    activeColor: string | number[];
    activeMix?: number;
    selectMix?: number;
    /**
     * 开启 TAA
     */
    enableTAA: boolean;
    /**
     * 相机抖动程度
     */
    jitterScale: number;
    /**
     * 开启光照
     */
    enableLighting: boolean;
    /**
     * 动画参数
     */
    animateOption: Partial<IAnimateOption>;
    /**
     * 地球模式参数
     */
    globelOtions: any;
    /**
     * layer point text 是否是 iconfont 模式
     */
    iconfont: boolean;
    onHover(pickedFeature: IPickedFeature): void;
    onClick(pickedFeature: IPickedFeature): void;
}
/**
 * 提供 Layer 管理服务
 */
export interface ILayerService {
    pickedLayerId: number;
    clock: Clock;
    alreadyInRendering: boolean;
    sceneService?: any;
    enableShaderPick: () => void;
    disableShaderPick: () => void;
    getShaderPickStat: () => boolean;
    clear(): void;
    add(layer: ILayer): void;
    addMask(mask: ILayer): void;
    initLayers(): void;
    startAnimate(): void;
    stopAnimate(): void;
    getSceneInited(): boolean;
    getLayers(): ILayer[];
    getRenderList(): ILayer[];
    getLayer(id: string): ILayer | undefined;
    getLayerByName(name: string): ILayer | undefined;
    cleanRemove(layer: ILayer, refresh?: boolean): void;
    remove(layer: ILayer, parentLayer?: ILayer): void;
    removeAllLayers(): void;
    updateLayerRenderList(): void;
    renderLayers(type?: string): void;
    setEnableRender(flag: boolean): void;
    getOESTextureFloat(): boolean;
    destroy(): void;
}
export {};
